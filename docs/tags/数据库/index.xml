<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>数据库 on zenos blog</title>
    <link>https://reacer.github.io/blog/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/</link>
    <description>Recent content in 数据库 on zenos blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sat, 15 Feb 2020 14:34:29 +0800</lastBuildDate>
    
	<atom:link href="https://reacer.github.io/blog/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Innodb事务隔离原理</title>
      <link>https://reacer.github.io/blog/posts/2020-02-15-innodb/</link>
      <pubDate>Sat, 15 Feb 2020 14:34:29 +0800</pubDate>
      
      <guid>https://reacer.github.io/blog/posts/2020-02-15-innodb/</guid>
      <description>事务概念  脏读:读取到其他未提交事务修改的内容 不可重复读: 同一个事务内两次读取到的内容不一样。因为在两次读同一数据之间可能被其他事务修改，导致两次读区到的数据不一样 可重复读: 同一事务内两次读取同一数据是一样的。sql第一次读取数据后,对数据加悲观锁，这样其他事务就不会对数据进行修改 幻读: 同一个事务第一次查询一个数据不存在，第二次查询又存在。可重复读只能解决已经存在的数据。对于插入无效。例如一个事务查询一条数据不存在,准备插入该数据，但是其他事务已经插入该数据并提交，后面该事务插入该数据会出现失败。  SQL标准中事务隔离级别  未提交读 无隔离,允许脏读存在。一般数据库不会采用，任何操作都不会加锁 已提交读 只能读取到已经提交事务的数据，可避免脏读。但是存在不可重复读的现象 可重复读 同一个事务内两次读取同一个数据是一样的。但是对于不存在的数据会不一样,存在幻读。InnoDB默认隔离级别 可串行化 所有事务串行化执行。不存在幻读。该级别没有并发,性能最差  InnoDB MVVC(Multi-Version Concurrency Control,多版本并发控制) MVVC实现机制 1. InnoDB在每行数据都增加两个隐藏字段。一个记录创建的版本号，一个记录删除的版本号。 2. 每个事务开始时都会有一个事务号-事务号递增。 3. 被操作的数据会生成一条新的临时数据行，在事务提交前其他事务不可见。 4. 对于数据的更新(增加、删除、更新)操作成功,事务提交时会将这个版本号后更新到数据行中。如果发现临时数据的版本号不大于原数据行的版本号，说明数据别其他事务修改，数据更新失败，事务回滚。这样可以保证事务之间互不影响，并且不存在锁的问题  MVVC下的CRUD 1. select 如果数据库隔离级别设置未RR(可重复读),innoDB返回数据必须满足两个条件 - 数据的版本号必须不大于事务的版本号。这可以保证事务开始之前或事务创建时数据已经存在 - 数据的删除版本号必须未定义或比事务版本号大，可以保证事务开始之前这个数据没有被删除 2. insert InnoDB为新数据的当前版本号设置为该事务号 3. delete InnoDB会将当前事务版本号设置为这行数据的删除版本号 4. update InnoDB会写一个这行数据的拷贝,这个拷贝的版本号为当前事务版本号,同步会将该版本号写入旧行的删除版本号里  </description>
    </item>
    
  </channel>
</rss>