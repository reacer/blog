---
title: "Innodb事务隔离原理"
date: 2020-02-15T14:34:29+08:00
draft: false
---

## 事务概念
1. 脏读:读取到其他未提交事务修改的内容
2. 不可重复读: 同一个事务内两次读取到的内容不一样。因为在两次读同一数据之间可能被其他事务修改，导致两次读区到的数据不一样
3. 可重复读: 同一事务内两次读取同一数据是一样的。sql第一次读取数据后,对数据加悲观锁，这样其他事务就不会对数据进行修改
4. 幻读: 同一个事务第一次查询一个数据不存在，第二次查询又存在。可重复读只能解决已经存在的数据。对于插入无效。例如一个事务查询一条数据不存在,准备插入该数据，但是其他事务已经插入该数据并提交，后面该事务插入该数据会出现失败。
## SQL标准中事务隔离级别
1. 未提交读
    无隔离,允许**脏读**存在。一般数据库不会采用，任何操作都不会加锁
2. 已提交读
    只能读取到已经提交事务的数据，可避免脏读。但是存在**不可重复读**的现象
3. 可重复读
    同一个事务内两次读取同一个数据是一样的。但是对于不存在的数据会不一样,存在**幻读**。InnoDB默认隔离级别
4. 可串行化
    所有事务串行化执行。不存在幻读。该级别没有并发,性能最差


## InnoDB MVVC(Multi-Version Concurrency Control,多版本并发控制)

### MVVC实现机制
    1. InnoDB在每行数据都增加两个隐藏字段。一个记录创建的版本号，一个记录删除的版本号。
    2. 每个事务开始时都会有一个事务号-事务号递增。
    3. 被操作的数据会生成一条新的临时数据行，在事务提交前其他事务不可见。
    4. 对于数据的更新(增加、删除、更新)操作成功,事务提交时会将这个版本号后更新到数据行中。如果发现临时数据的版本号不大于原数据行的版本号，说明数据别其他事务修改，数据更新失败，事务回滚。这样可以保证事务之间互不影响，并且不存在锁的问题
    
### MVVC下的CRUD
    1. select
        如果数据库隔离级别设置未RR(可重复读),innoDB返回数据必须满足两个条件
            - 数据的版本号必须不大于事务的版本号。这可以保证事务开始之前或事务创建时数据已经存在
            - 数据的删除版本号必须未定义或比事务版本号大，可以保证事务开始之前这个数据没有被删除
    2. insert
        InnoDB为新数据的当前版本号设置为该事务号
    3. delete
        InnoDB会将当前事务版本号设置为这行数据的删除版本号
    4. update
        InnoDB会写一个这行数据的拷贝,这个拷贝的版本号为当前事务版本号,同步会将该版本号写入旧行的删除版本号里


