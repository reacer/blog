---
title: "缓存常见问题"
date: 2020-02-15T21:30:02+08:00
draft: true
categories: ["存储"]
tags: ["redis","NoSQL"]
---


### 缓存雪崩
同一时刻出现大面积缓存失效，导致大量查询数据库
> 解决办法:
> 1. 加锁、队列方式保证不会出现大量的线程对数据库同时进行读写操作
> 2. 数据设置不同的过期时间

### 缓存穿透
用户查询数据库中不存在的数据，当然缓存中也没有。每次缓存查不到的数据都会到数据库中查询，导致数据库查询频率大。也是缓存命中率的问题。
> 解决办法:
> 布隆过滤器: 将所有数据hash到一个足够大的bitmap中，一个不存在的数据会被这个bitmap拦截掉，从而避免了对底层存储系统的压力
> 如果一个查询结构为空，我们仍然缓存该空结果


### 缓存预热
系统上线前，直接将相关的缓存数据直接加载到缓存系统
> 1. 直接写个缓存刷新页面，上线时手工操作下
> 2. 数据量不大，可以在项目启动的时候自动进行加载
> 3. 定时刷新缓存

### 缓存更新
1. 定时清理过滤缓存
2. 当有用户请求过来时，判断这个请求所用到的缓存是否过期，过期的话就阖底层系统得到新数据并更新缓存

### 缓存降级
当访问量剧增、服务出现问题(如响应慢或不响应)或非核心服务影响到核心流程的性能时，仍然要保证服务还是可用的，即使是有损服务。系统可根据关键数据自动降级、也可以配置开关实现人工自动降级。
降级目的是保证核心服务可用，即使是有损的。而且有些服务是无法降级的(如加入购物车、结算)。
> 1. 一般： 服务偶尔因为网络抖动或者服务正在上线而超时，可以自动降级
> 2. 警告： 服务在一段时间内成功率有波动（95~100%），可以自动降级或人工降级，并发送告警
> 3. 错误： 比如可用率低于90%，或数据库连接池打爆，或者访问量激增到系统承受最大值，可自动降级或人工降级
> 4. 严重错误
> 服务降级的目的是防止redis服务故障，导致数据库跟着一起发生雪崩问题。对于不重要的缓存数据，可以采用服务降级策略，例如redis出现问题时，不查数据库，直接返回默认值给用户

### 热点数据、冷数据
1. 热点数据缓存才有价值
2. 冷数据可能还没有被再次访问就已经被挤出内存，不仅占用内存，而且价值不大。频繁修改的数据，看情况考虑使用缓存


### memcache与redis区别有哪些?
1. memcache把数据全部存在内存之中，断电后会挂掉，数据不对超过内存大小。redis有部份存在硬盘上，redis可以持久化其数据
2. memcache只支持字符串，redis支持丰富的数据类型，如list、set、zset、hash等
3. redis支持集群模式扩容


### 单线程的redis为什么这么快?
1. 全内存操作
2. 单线程操作、避免频繁的上下文切换
3. 采用非阻塞多路IO复用机制



### redis过期策略、内存淘汰机制
redis采用的是定期删除+惰性删除策略:
> 定时删除：用一个定时器负责监视key， 过期自动删除。虽然内存即使释放，但是十分消耗CPU资源。因此redis不采用这一策略
> 定期删除： redis默认100ms检查是否有过期的key,有过期的key则删除。需要说明的是redis不是每个100ms将所有的key检查一次，而是随机抽取进行检查。因此,只采用定期删除策略，会导致很多key到时间没有删除。
> 惰性删除： 获取某个key时,redis会检查key是否已过期，如果过期就删除。
> 如果定期删除没有删除key，又没有请求访问key，redis内存会越来越高，那么应该采用内存淘汰机制。

内存淘汰机制:
> volatile-lru: 从已设置过期时间的数据集中挑选最近最少使用的数据淘汰
> volatile-ttl: 从已设置过期时间的数据集中挑选将要过期的数据淘汰
> valatile-random: 从已设置过期时间的数据集中任意选择数据淘汰
> allkeys-lru: 从数据集中挑选最近最少使用的数据淘汰
> allkeys-random: 从数据集中任意选择数据淘汰
> no-enviction: 禁止驱逐数据，新写入操作会报错 （腾讯云默认配置）


### redis为什么是单线程?
redis是基于内存操作，CPU不是瓶颈，redis瓶颈在内存大小或网络带宽。
    1. 绝大部分请求是纯粹内存操作
    2. 采用单线程，避免了不必要的上下文切换和竞争条件
    3. 非阻塞IO优
    
 1. 速度快，数据存于内存，类似于hash，查找操作时间复杂度都是O(1)。
 2.  支持丰富数据类型，支持string，list，set，sorted set，hash
 3.  支持事务，操作都是原子性，所谓的原子性就是对数据的更改要么全部执行、要么全部不执行
 4. 丰富的特性： 可用于缓存，消息，按key设置过期时间
 5. 事务机制：
     1.  如果对这个key操作，不要求顺序: 准备一个分布式锁，大家支抢锁，抢到锁的就做set操作即可
     2.  如果对这个key操作，要求顺序: 分布式锁+时间戳。
     3.  利用队列，将set方式变成串行访问也可以,redis遇到高并发问题，redis内部已经帮你处理好并发问题了


### redis集群部署，如何保证数据一致性?
主从复制、读写分离
1. master-slave部署: master可以读写，当写操作发生时自动将数据同步到从数据库。
2. 









